<system>
  log_level debug
  # log_level error
</system>

# bind fluentd on IP 0.0.0.0
# port 24224
<source>
  @type forward
  port 24224
  bind 0.0.0.0
</source>

<source>
  @type http
  port 9880
  bind 0.0.0.0
  body_size_limit 32m
  keepalive_timeout 10s
</source>

<source>
  @type rabbitmq
  tag rabbitmq-tag
  host rabbitmq
  # or hosts ["192.168.1.1", "192.168.1.2"]
  port 5672
  user guest
  pass guest
  vhost /
  # exchange rabbitmq-tag # not required. if specified, the queue will be bound to the exchange
  queue bar
  # routing_key hoge # if not specified, the tag is used
  heartbeat 10 # integer as seconds or :server (interval specified by server)
  <parse>
    @type json # or msgpack, ltsv, none
  </parse>
</source>

# Fluentd will send its own logs to this label.
# This is useful for monitoring Fluentd logs.
<label @FLUENT_LOG>
  <match fluent.*>
    @type stdout
  </match>
</label>

<filter rabbitmq-tag>
  @type record_transformer
  enable_ruby
  <record>
    # jsonized_record ${record.to_json}
    # tag ${tag}
    spans ${ record["resourceSpans"][0]["scopeSpans"][0]["spans"][0] }
    resources ${ record["resourceSpans"][0]["resource"] }
  </record>
  remove_keys resourceSpans
</filter>

<filter rabbitmq-tag>
  @type record_transformer
  enable_ruby
  <record>
    uuaaAttr ${ record["spans"]["attributes"].find {|attr| attr["key"] == "UUAA"} }
  </record>
  remove_keys resourceSpans
</filter>

<filter rabbitmq-tag>
  @type record_transformer
  enable_ruby
  <record>
    spanId ${ record["spans"]["spanId"] }
    parentSpanId ${ record["spans"]["parentSpanId"] }
    traceId ${ record["spans"]["traceId"] }
    name ${ record["spans"]["name"] }
    startTimeUnixNano ${ record["spans"]["startTimeUnixNano"] }
    endTimeUnixNano ${ record["spans"]["endTimeUnixNano"] }
    status ${ record["spans"]["status"]["code"] }
    kind ${ record["spans"]["kind"] }
    attributes ${ record["spans"]["attributes"].map { |attr| { attr["key"] => attr["value"][attr["value"].keys[0]] } } }
    resources ${ record["resources"]["attributes"].map { |attr| { attr["key"] => attr["value"][attr["value"].keys[0]] } } }
    uuaa ${ record["uuaaAttr"] ? record["uuaaAttr"]["value"][record["uuaaAttr"]["value"].keys[0]] : "default" }
  </record>
  remove_keys spans,resources,uuaaAttr
</filter>

<match rabbitmq-tag>
  @type rewrite_tag_filter
  <rule>
    key uuaa
    pattern /(.+)/
    tag     $1
  </rule>
</match>

<filter **>
  @type record_transformer
  remove_keys uuaa
</filter>


# sendlog to the elasticsearch
# the host must match to the elasticsearch
# container service
<match **>
  @type copy
  <store>
    @type  elasticsearch
    @id    elasticsearch_out
    host elasticsearch
    port 9200
    logstash_format true
    logstash_dateformat %Y%m%d
    logstash_prefix span-${tag}
    request_timeout 20s
    include_tag_key true
    tag_key @log_name
    <buffer>
      flush_mode interval
      flush_interval 5s
      retry_wait 5s
      retry_max_interval 60s
    </buffer>
  </store>
  <store>
    @type stdout
  </store>
</match>